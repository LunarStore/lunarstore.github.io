<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.halfmantou.xyz","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="前言前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。 首先明确目前XV6的cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础">
<meta property="og:type" content="article">
<meta property="og:title" content="这才是计科之 Onix &amp; XV6 源码分析（3、Unix-like系统的进程调度模块）">
<meta property="og:url" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/index.html">
<meta property="og:site_name" content="碎碎念念">
<meta property="og:description" content="前言前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。 首先明确目前XV6的cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png">
<meta property="og:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png">
<meta property="article:published_time" content="2024-06-08T04:00:00.000Z">
<meta property="article:modified_time" content="2025-09-29T14:24:25.814Z">
<meta property="article:author" content="半个馒头">
<meta property="article:tag" content="类Unix源码剖析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png">

<link rel="canonical" href="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>这才是计科之 Onix & XV6 源码分析（3、Unix-like系统的进程调度模块） | 碎碎念念</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">碎碎念念</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">59</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/LunarStore" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.halfmantou.xyz/2024/06/08/xv6/Scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="半个馒头">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="碎碎念念">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          这才是计科之 Onix & XV6 源码分析（3、Unix-like系统的进程调度模块）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-08 12:00:00" itemprop="dateCreated datePublished" datetime="2024-06-08T12:00:00+08:00">2024-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-29 22:24:25" itemprop="dateModified" datetime="2025-09-29T22:24:25+08:00">2025-09-29</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经分析了XV6的启动流程以及内存管理，接下来，我们探究进程调度的实现。与其说进程调度，我觉得可以顺应内存的虚拟化的叫法，将进程调度称为“CPU的虚拟化”更加贴切。</p>
<p>首先明确目前XV6的cpu的状态如下：关中断 &amp; 进入了保护模式 &amp; 安装了包括【内核&amp;用户】【代码&amp;数据】段描述符 &amp; BSP分配了一个4K的内核栈 &amp; 开启了以kmap为基础的粒度为4K的内核分页。</p>
<p>Onix相关链接：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix">github仓库链接</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qM4y127om/">B站配套视频链接</a>。</p>
</li>
</ul>
<p>XV6-x86的github链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public">链接</a>。</li>
</ul>
<span id="more"></span>

<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>对于中断的部分，这里会涉及大量硬件相关的知识，由于博主的目的是了解OS的基本框架，所以硬件相关的知识储备可能不会太深，如果你是想弄清某个硬件具体实现，这篇博客可能不适合你。</p>
<p>这里总结一下我对中断的理解：</p>
<p>引发中断的方式有三种：外中断、异常、软中断。</p>
<ul>
<li><p>外中断：就是由外部中断控制器通知 CPU 某个事件完成了，比如：磁盘寻道完成可以进行读写了、UART输入寄存器非空（可读）、UART输出寄存器为空（可写）、键盘缓冲有数据了（可读）等等。</p>
</li>
<li><p>异常是 CPU 在执行过程中，因为出错而执行不下去了，比如：除零异常、因为虚拟页面还没映射发生缺页异常、对只读段进行写操作触发段错误异常等等。</p>
</li>
<li><p>软中断，可以认为是应用程序和操作系统沟通的一种方式，运行在低优先级程序想要对硬件做IO，但是由于只有处于特权级的内核能够直接和设备打交道，从而低优先级程序必须通过某种机制来完成特权级转换，这种机制就是软中断。我们也可以将实现这种功能的函数称为系统调用。</p>
</li>
</ul>
<p>如有些教科书那样，我们也可以把异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关。</p>
<h3 id="Onix单核处理器的中断原理"><a href="#Onix单核处理器的中断原理" class="headerlink" title="Onix单核处理器的中断原理"></a>Onix单核处理器的中断原理</h3><p>单核PC机上，一般会采用（主从）两片 8259a PIC（programmable interrupt controller），将PIC的INT引脚接到CPU的一个引脚上，如下图，图片引用自onix的文档，如有侵权，可告知删除：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/8259a.drawio.png"></p>
<p>从图中可以看到有两个8259a，上面那个8259a是主PIC，它的INT引脚直接接到CPU上；下面那个8259a的INT引脚接到主PIC的IR2引脚，所以它是从PIC。 每一个PIC的引脚会接一个外设，（如果对应的引脚没被屏蔽的话）外设会通过PIC间接向CPU发中断。</p>
<p>在PIC正式工作前，需要对其进行一系列初始化。初始化操作由cpu发送一系列的控制字完成。有两类控制字：</p>
<ul>
<li><p>初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；</p>
</li>
<li><p>操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；</p>
</li>
</ul>
<p>ICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。因为某些设置之间是具有依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，<strong>必须依次写入</strong> ICW1、ICW2、ICW3、ICW4；</p>
<p>OCW 来操作控制 8259A，中断的屏蔽和中断处理结束就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。</p>
<p><strong>具体细节非常推荐读者去阅读一下Onix文档，讲的真的很细致</strong>：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md">https://github.com/StevenBaby/onix/blob/dev/docs/04%20%E4%B8%AD%E6%96%AD%E5%92%8C%E6%97%B6%E9%92%9F/033%20%E5%A4%96%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8.md</a></p>
<p>8259a中断控制器的初始化就是一种固定套路，截取Onix代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_CTRL 0x20 <span class="comment">// 主片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_M_DATA 0x21 <span class="comment">// 主片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_CTRL 0xa0 <span class="comment">// 从片的控制端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_S_DATA 0xa1 <span class="comment">// 从片的数据端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC_EOI 0x20    <span class="comment">// 通知中断控制器中断结束</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断控制器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pic_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主PIC</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_M_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_M_DATA, <span class="number">0x20</span>);       <span class="comment">// ICW2: 起始中断向量号 0x20</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_M_DATA, <span class="number">0b00000100</span>); <span class="comment">// ICW3: IR2接从片.</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_M_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从PIC</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_S_CTRL, <span class="number">0b00010001</span>); <span class="comment">// ICW1: 边沿触发, 级联 8259, 需要ICW4.</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_S_DATA, <span class="number">0x28</span>);       <span class="comment">// ICW2: 起始中断向量号 0x28</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_S_DATA, <span class="number">2</span>);          <span class="comment">// ICW3: 设置从片连接到主片的 IR2 引脚</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_S_DATA, <span class="number">0b00000001</span>); <span class="comment">// ICW4: 8086模式, 正常EOI</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">outb</span>(PIC_M_DATA, <span class="number">0b11111111</span>); <span class="comment">// OCW1：屏蔽字，关闭主PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class="line">    <span class="built_in">outb</span>(PIC_S_DATA, <span class="number">0b11111111</span>); <span class="comment">// OCW1：屏蔽字，关闭从PIC所有中断，后面需要什么中断再依据需求打开。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU在处理每个外中断后，需要向PIC发生一个结束字为的是通知PIC中断处理结束，具体中断结束方式由OCW2 来设置。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知中断控制器，中断处理结束</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_eoi</span><span class="params">(<span class="type">int</span> vector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vector &gt;= <span class="number">0x20</span> &amp;&amp; vector &lt; <span class="number">0x28</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vector &gt;= <span class="number">0x28</span> &amp;&amp; vector &lt; <span class="number">0x30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">outb</span>(PIC_M_CTRL, PIC_EOI);</span><br><span class="line">        <span class="built_in">outb</span>(PIC_S_CTRL, PIC_EOI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此单核OS中断的初始化到这里就结束了。</p>
<h3 id="XV6多核处理的中断原理"><a href="#XV6多核处理的中断原理" class="headerlink" title="XV6多核处理的中断原理"></a>XV6多核处理的中断原理</h3><p>多核处理器中断控制器的结构更为复杂，因为偏向硬件，这里就只记录一下我对APIC的理解，理解不会太深，如果有错误，非常欢迎读者纠正！</p>
<p>首先还是供上架构框图：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/APICStructure.png"></p>
<p>图片截取自：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>
<p>注释：</p>
<p>BSP：bootstrap processor，可以简单理解为主处理器。</p>
<p>APx：application processors ，可以简单理解为从处理器。</p>
<p>关于BSP和APx的关系这里先埋个伏笔。在【AP（从）处理器的启动】段落会进行详细叙述。</p>
<p>从图中的上半部分可以了解到，每个CPU各自接着一个Local APIC（Advanced Programmable Interrupt Controller）。注意，<strong>每个lapic和cpu是封装在一起的</strong>（这里并不严谨，是否和cpu封装在一起其实和cpu的架构有关）。后面我们会看到，不止APIC，在多核cpu上，它的每一个cpu都有自己的一套cpu寄存器，比如：esp、eip、eflag等等。具体情况我们在“进程调度”段落进行详细讲解。</p>
<p>从图的下半部分，我们可以了解到所有的lapic都接到了ICC（interrupt controller communications） Bus上，并且，总线上还接了一个IO APIC，这里的<strong>ioapic是和cpu分离的</strong>，它被接在cpu的外部。<strong>ioapic会接收来自各个外设的中断。然后对各个外设发来的中断做一些判断和处理，再将中断的IRQ号和lapic的ID封装在一条“报文”中分发給对应的lapic</strong>，具体发给哪些lapic，我们可以通过配置ioapic来进行设置。ioapic左边其实是有很多引脚（实际16个，如果级联了8259a可能会更多）每个引脚都可以接外设。有趣的是，从图中ioapic的左边可以看到，<strong>ioapic的引脚还可以接8259a PIC控制器</strong>，这非常完美的兼容了单核cpu的中断控制器的架构。</p>
<p>iopic是依据重定向表项 RTE(Redirection Table Entry)来构建“报文“，RTE对每一个中断都会有一项64位的entry。通过entry，可以单独设置ioapic在收到中断后对中断的操作。每一项entry描述：中断对应的中断向量？中断有没有使能？中断传输状态？发给哪个lapic？</p>
<p>每个lapic都有一个唯一的ID，cpu可以在特定的内存（device space）上来查询自己所对应的lapic的ID号，lapic的ID其实也唯一标识了一个cpu。lapic会根据自己的ID从ICC Bus上接收属于自己的中断”报文“，然后经过一系列检查最后将中断发给cpu，当cpu处理完中断后，会反馈给自己的lapic，lapic收到cpu的回复后，同样将中断处理完毕的消息通知给ioapic，这点和单核架构中，cpu处理完中断后向master pic发送PIC_EOI是一样的道理。</p>
<p>特别的是，lapic也可以像ioapic那样作为中断“源”（这里可能不严谨，但是可以类比去理解），向其他的lapic发送中断“报文”，这是通过ICR(Interrupt Command Register)寄存器实现，ICR的结构和ioapic的RTE表的entry结构类似，也有中断向量号、lapic的ID等字段。lapic主动向其他lapic发送中断“报文”最常见的场景就是BSP去启动其他APs，这一般通过会发送INIT or STARTUP IPI（interprocessor interrupts）。</p>
<p>由于XV6中cpu对lapic、iopic初始化代码上，依赖于mpinit函数，而mpinit和多处理器内容相关，所以lapic、iopic初始化我们放到”AP（从）处理器的启动”段落进行讨论。</p>
<p>关于Local APIC和IO APIIC详细内容可以参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46645613/article/details/119207945">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>
<h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>之前一直在介绍中断相关的外设，接下来我们看看cpu内部是怎么利用寄存器来定义中断的。</p>
<p>因为中断不止一个，所以，和全局描述符类表似，中断表也是通过一个大的数组来记录每一个中断的属性。数组中每一个Entry格式如下图，每一个Entry同样是8个字节：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/IDT_Entry.png"></p>
<ul>
<li><p>Offset：记录中断门或陷阱门的处理函数的地址。</p>
</li>
<li><p>Selector：处理函数的段选择子。</p>
</li>
<li><p>Type：标记是中断门还是陷阱门。 <strong>注意：中断门会自动清除eflag寄存器的FL_IF标志位，而陷阱门则保留eflag的FL_IF标志位。</strong> 也即中断门会i自动关（外）中断，而陷阱门则不会有关中断的操作！</p>
</li>
<li><p>S：必须为0。</p>
</li>
<li><p>DPL：描述符可以被哪个特权级使用。对于中断门一般是0x0，对于陷阱门就是0x3（DPL_USER）。</p>
</li>
<li><p>P：是否有效，固定填1.</p>
</li>
</ul>
<p>XV6相关代码注释写的非常好，上面的中文注释也是参考XV6的注释写的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gate descriptors for interrupts and traps</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gatedesc</span> &#123;</span><br><span class="line">  uint off_15_0 : <span class="number">16</span>;   <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">  uint cs : <span class="number">16</span>;         <span class="comment">// code segment selector</span></span><br><span class="line">  uint args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">  uint rsv1 : <span class="number">3</span>;        <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">  uint type : <span class="number">4</span>;        <span class="comment">// type(STS_&#123;IG32,TG32&#125;)</span></span><br><span class="line">  uint s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line">  uint dpl : <span class="number">2</span>;         <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">  uint p : <span class="number">1</span>;           <span class="comment">// Present</span></span><br><span class="line">  uint off_31_16 : <span class="number">16</span>;  <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line"><span class="comment">//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//        the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//        this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, d)                \</span></span><br><span class="line"><span class="meta">&#123;                                                         \</span></span><br><span class="line"><span class="meta">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \</span></span><br><span class="line"><span class="meta">  (gate).cs = (sel);                                      \</span></span><br><span class="line"><span class="meta">  (gate).args = 0;                                        \</span></span><br><span class="line"><span class="meta">  (gate).rsv1 = 0;                                        \</span></span><br><span class="line"><span class="meta">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \</span></span><br><span class="line"><span class="meta">  (gate).s = 0;                                           \</span></span><br><span class="line"><span class="meta">  (gate).dpl = (d);                                       \</span></span><br><span class="line"><span class="meta">  (gate).p = 1;                                           \</span></span><br><span class="line"><span class="meta">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>中断描述符寄存器如下：</p>
<p>高32位存放中断描述符表的基地址，低16位存放中断描述符表的大小（字节为单位）。</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/IDTR.png"></p>
<h2 id="AP（从）处理器的启动"><a href="#AP（从）处理器的启动" class="headerlink" title="AP（从）处理器的启动"></a>AP（从）处理器的启动</h2><p>首先还是回归main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap processor starts running C code here.</span></span><br><span class="line"><span class="comment">// Allocate a real stack and switch to it, first</span></span><br><span class="line"><span class="comment">// doing some setup required for memory allocator to work.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">kinit1</span>(end, <span class="built_in">P2V</span>(<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>)); <span class="comment">// 内存内存管理已讲</span></span><br><span class="line">  <span class="built_in">kvmalloc</span>();      <span class="comment">// 内存内存管理已讲</span></span><br><span class="line">  <span class="built_in">mpinit</span>();        <span class="comment">// detect other processors</span></span><br><span class="line">  <span class="built_in">lapicinit</span>();     <span class="comment">// interrupt controller</span></span><br><span class="line">  <span class="built_in">seginit</span>();       <span class="comment">// 内存内存管理已讲</span></span><br><span class="line">  <span class="built_in">picinit</span>();       <span class="comment">// disable pic // 禁用单核架构下的8259A，实现很简单，这里就不去贴代码了</span></span><br><span class="line">  <span class="built_in">ioapicinit</span>();    <span class="comment">// another interrupt controller</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">pinit</span>();         <span class="comment">// process table // 实现很简单就是对自ptable的自旋锁进行一个初始化。读者可以自行阅读代码，这里就不过多赘述。</span></span><br><span class="line">  <span class="built_in">tvinit</span>();        <span class="comment">// trap vectors</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">startothers</span>();   <span class="comment">// start other processors</span></span><br><span class="line">  <span class="built_in">kinit2</span>(<span class="built_in">P2V</span>(<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>), <span class="built_in">P2V</span>(PHYSTOP)); <span class="comment">// 内存内存管理已讲</span></span><br><span class="line">  <span class="built_in">userinit</span>();      <span class="comment">// first user process // 就是对init进程的内核栈做一个初始化。利用了ROP（面向返回点编程）编程思想。因为这又是一个大主题，本文不会过多讲解。以后有机会在另开一篇博客专门讨论。</span></span><br><span class="line">  <span class="built_in">mpmain</span>();        <span class="comment">// finish this processor&#x27;s setup // 进入mpmain</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other AP CPUs jump here from entryother.S.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mpenter</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  switchkvm();  <span class="comment">// AP的内核页表换成kpgdir</span></span><br><span class="line">  <span class="built_in">seginit</span>();    <span class="comment">// 内存内存管理已讲</span></span><br><span class="line">  <span class="built_in">lapicinit</span>();  <span class="comment">// 作用同main函数中BSP核执行的lapicinit函数</span></span><br><span class="line">  <span class="built_in">mpmain</span>();     <span class="comment">// 进入mpmain</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BSP、APS最终都会进入改函数。</span></span><br><span class="line"><span class="comment">// 主要工作就是</span></span><br><span class="line"><span class="comment">//    1、加载中断描述表。</span></span><br><span class="line"><span class="comment">//    2、设置状态，已启动。</span></span><br><span class="line"><span class="comment">//    3、 进入调度循环。</span></span><br><span class="line"><span class="comment">// Common CPU setup code.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mpmain</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cprintf</span>(<span class="string">&quot;cpu%d: starting %d\n&quot;</span>, <span class="built_in">cpuid</span>(), <span class="built_in">cpuid</span>());</span><br><span class="line">  <span class="built_in">idtinit</span>();       <span class="comment">// load idt register // 使用lidt命令加载中断描述符</span></span><br><span class="line">  <span class="built_in">xchg</span>(&amp;(<span class="built_in">mycpu</span>()-&gt;started), <span class="number">1</span>); <span class="comment">// tell startothers() we&#x27;re up</span></span><br><span class="line">  <span class="built_in">scheduler</span>();     <span class="comment">// start running processes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下我们要从BSP执行的maiin函数开始，深入分析以上代码的作用。</p>
<h3 id="mpinit：探测各个cpu"><a href="#mpinit：探测各个cpu" class="headerlink" title="mpinit：探测各个cpu"></a>mpinit：探测各个cpu</h3><p>该部分主要参考：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf">多处理器规范</a>，因为我英语也是很菜，所以硬着头皮捡重点去看了一部分。</p>
<p>这里对多核处理器的启动流程做一个简单总结：我们可以理解为，多核CPU中，有一个CPU被设计成BSP，其他的CPU都被设计成AP。当然，在实际硬件设计上为了考虑容错性，任何一个CPU都能成为BSP核。 <strong>系统最开始，BSP有对硬件的绝对控制权，包括去控制其他AP的启动和停止。为了启动其他AP核，BSP首先通过三种可能的方式搜索MP floating pointer structure，如果找到了一个有效的MP floating pointer structure就去遍历MP configuration table查询处理器信息和ioapic的信息；如果无法找到一个有效MP floating pointer structure，那就认为系统只有一个CPU——BSP。在所有CPU启动后，BSP就退化成AP，系统不存在BSP、AP之分。</strong> 当然，我们需要要记录BSP CPU的lapic的ID（这个ID也唯一标识着CPU），这样我们才知道谁可以去其控制其他CPU的停止。在BSP启动其他AP前，因为AP CPU是暂停状态，所以其他AP无法执行OS代码，并且大部分中断都是被禁用，<strong>但是INIT or STARTUP interprocessor interrupts (IPIs)不会被屏蔽，当AP收到来自BSP的INIT or STARTUP中断，就会启动它自己。</strong> AP在收到BSP的启动中断后，也会进入保护模式、<strong>有自己的独立的一套寄存器</strong>、设置自己的全局描述符、开启分页、有自己的堆栈等。</p>
<p>首先BSP会通过三种方式去搜索MP floating pointer structure，<strong>三种搜索范围都在1M以内，因为MP floating pointer structure就是由BIOS提供，而BISO寻址范围就1M</strong>：</p>
<ol>
<li>In the first kilobyte of Extended BIOS Data Area (EBDA), or</li>
<li>Within the last kilobyte of system base memory, or</li>
<li>In the BIOS ROM address space between 0F0000h and 0FFFFFh.</li>
</ol>
<p>低1M内存的内存映射参考：<a target="_blank" rel="noopener" href="https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29">https://wiki.osdev.org/BDA#BIOS_Data_Area_.28BDA.29</a></p>
<p>MP Configuration Data Structures整体框架如下图，图解了MP floating pointer structure、MP Configuration Table Header、Table Entries三者之间的一个关系，先了解一下大致的框架，接下来我门逐一剖析。</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/MP_Configuration_Data_Structures.png"></p>
<p>MP floating pointer structure图解如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/MP_floating_pointer_structure.png"></p>
<p>主要关注它的PHYSICAL ADDRESS POINTER，它指向MP config table的物理地址。</p>
<p>MP Configuration Table Header结构如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/MP_configuration_table_header.png"></p>
<p>主要关注几个字段：</p>
<ul>
<li><p>MEMORY-MAPPED ADDRESS OF LOCAL APIC：描述 cpu（<strong>每个CPU都将它的lapic映射到了同一个物理地址</strong>）的lapic的寄存器物理地址。注意这里是”每个cpu”，虽然是同一个物理地址，但是在每一个cpu去读的时候，分别映射到了各自的lapic的寄存器地址上了。</p>
</li>
<li><p>BASE TABLE LENGTH：整个table的长度，虽然存在扩展表长度，但是我们还用不到。</p>
</li>
</ul>
<p>MP Configuration Table Header后面会跟上各自类型的Base MP Configuration Table Entries，每个Entry的第一个字节会标明其类型，并且每种Entry的长度都各自固定，所以我们可以通过一个循环来遍历每个Entry，一共有5种类型的Entry，如下图：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/entry_types.png"></p>
<p>XV6中我们主要关注Processor Entries和I&#x2F;O APIC两种类型的Entry。</p>
<p>Processor Entries结构如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/processor_entry.png"></p>
<p>主要关注LOCAL APIC ID，如该字段名字那样，就是代表和CPU绑定的lapic的ID，通过它我们也可以唯一标识一个CPU。</p>
<p>I&#x2F;O APIC Entries结构如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/ioapic_entry.png"></p>
<p>主要关注I&#x2F;O APIC ID，代表I&#x2F;O APIC的ID。</p>
<p>然后上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mpinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uchar *p, *e;</span><br><span class="line">  <span class="type">int</span> ismp;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mp</span> *mp;              <span class="comment">// 前面提到的MP floating pointer structure</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mpconf</span> *conf;        <span class="comment">// 前面提到的MP Configuration Table Header</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mpproc</span> *proc;        <span class="comment">// 前面提到的Processor Entries</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">mpioapic</span> *ioapic;    <span class="comment">// 前面提到的I/O APIC Entries</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((conf = <span class="built_in">mpconfig</span>(&amp;mp)) == <span class="number">0</span>)     <span class="comment">// 用上面提到的三种方法寻找MP floating pointer structure，并且判断它的合法性，然后将结构体里面的PHYSICAL ADDRESS POINTER（指向MP Configuration Table Header）作为返回值</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Expect to run on an SMP&quot;</span>);</span><br><span class="line">  ismp = <span class="number">1</span>;</span><br><span class="line">  lapic = (uint*)conf-&gt;lapicaddr;     <span class="comment">// 将lapic的寄存器地址放到全局变量lapic中</span></span><br><span class="line">  <span class="keyword">for</span>(p=(uchar*)(conf<span class="number">+1</span>), e=(uchar*)conf+conf-&gt;length; p&lt;e; )&#123;  <span class="comment">// 依据MP Configuration Table Header遍历每一个Table Entry。</span></span><br><span class="line">    <span class="keyword">switch</span>(*p)&#123;</span><br><span class="line">    <span class="keyword">case</span> MPPROC:                      <span class="comment">// Processor Entries</span></span><br><span class="line">      proc = (<span class="keyword">struct</span> mpproc*)p;</span><br><span class="line">      <span class="keyword">if</span>(ncpu &lt; NCPU) &#123;</span><br><span class="line">        cpus[ncpu].apicid = proc-&gt;apicid;  <span class="comment">// apicid may differ from ncpu // 保存cpu的lapic的id</span></span><br><span class="line">        ncpu++;                       <span class="comment">// 找到一个CPU</span></span><br><span class="line">      &#125;</span><br><span class="line">      p += <span class="built_in">sizeof</span>(<span class="keyword">struct</span> mpproc);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> MPIOAPIC:                    <span class="comment">// I/O APIC Entries</span></span><br><span class="line">      ioapic = (<span class="keyword">struct</span> mpioapic*)p;</span><br><span class="line">      ioapicid = ioapic-&gt;apicno;      <span class="comment">// 将ioapicid存到全局变量，将来初始化的时候会用</span></span><br><span class="line">      p += <span class="built_in">sizeof</span>(<span class="keyword">struct</span> mpioapic);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> MPBUS:                       <span class="comment">// 其他的不关注，加上他们的大小去找下一个Table Entry。</span></span><br><span class="line">    <span class="keyword">case</span> MPIOINTR:</span><br><span class="line">    <span class="keyword">case</span> MPLINTR:</span><br><span class="line">      p += <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      ismp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!ismp)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Didn&#x27;t find a suitable machine&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mp-&gt;imcrp)&#123;</span><br><span class="line">    <span class="comment">// 如果之前是PIC Mode，就切换到APIC模式 </span></span><br><span class="line">    <span class="comment">// interrupt mode configuration register --&gt; IMCR</span></span><br><span class="line">    <span class="comment">// Bochs doesn&#x27;t support IMCR, so this doesn&#x27;t run on Bochs.</span></span><br><span class="line">    <span class="comment">// But it would on real hardware.</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x22</span>, <span class="number">0x70</span>);   <span class="comment">// Select IMCR</span></span><br><span class="line">    <span class="built_in">outb</span>(<span class="number">0x23</span>, <span class="built_in">inb</span>(<span class="number">0x23</span>) | <span class="number">1</span>);  <span class="comment">// Mask external interrupts.  // 进入APIC模式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mp-&gt;imcrp字段的解释如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/imcrp.png"></p>
<p>详细信息可以了解一下：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf">多处理器规范</a></p>
<h3 id="lapicinit：BSP初始化自己cpu的lapic"><a href="#lapicinit：BSP初始化自己cpu的lapic" class="headerlink" title="lapicinit：BSP初始化自己cpu的lapic"></a>lapicinit：BSP初始化自己cpu的lapic</h3><p>这部分和硬件强相关，我也了解不是特别多，尽可能的讲清楚吧。硬件相关的初始化深入下去也是一个无底洞。如果读者感兴趣的话，可以去查intel 64 and IA-32 卷3开发手册。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">lapicinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!lapic)    <span class="comment">// lapic就是上面mpinit函数在MP Configuration Table Header中得到的lapic寄存器的物理映射地址，所以说初始化的顺序非常严格！</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enable local APIC; set spurious interrupt vector.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));      <span class="comment">// 开启此cpu的APIC</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置时钟，属于lapic的本地中断</span></span><br><span class="line">  <span class="comment">// The timer repeatedly counts down at bus frequency</span></span><br><span class="line">  <span class="comment">// from lapic[TICR] and then issues an interrupt.</span></span><br><span class="line">  <span class="comment">// If xv6 cared more about precise timekeeping,</span></span><br><span class="line">  <span class="comment">// TICR would be calibrated using an external time source.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(TDCR, X1);                               <span class="comment">// 分频系数为X1</span></span><br><span class="line">  <span class="built_in">lapicw</span>(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER)); <span class="comment">// 以PERIODIC为周期，映射到0x20中断</span></span><br><span class="line">  <span class="built_in">lapicw</span>(TICR, <span class="number">10000000</span>);                         <span class="comment">// 时钟频率</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disable logical interrupt lines.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(LINT0, MASKED);                          <span class="comment">// 屏蔽LINT0（lapic本地中断</span></span><br><span class="line">  <span class="built_in">lapicw</span>(LINT1, MASKED);                          <span class="comment">// 屏蔽LINT1（lapic本地中断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disable performance counter overflow interrupts</span></span><br><span class="line">  <span class="comment">// on machines that provide that interrupt entry.</span></span><br><span class="line">  <span class="keyword">if</span>(((lapic[VER]&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xFF</span>) &gt;= <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">lapicw</span>(PCINT, MASKED);                        <span class="comment">// 屏蔽PCINT（好像是废话？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map error interrupt to IRQ_ERROR.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(ERROR, T_IRQ0 + IRQ_ERROR);            <span class="comment">// 0x20 + 0x13（ERROR）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear error status register (requires back-to-back writes).</span></span><br><span class="line">  <span class="built_in">lapicw</span>(ESR, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">lapicw</span>(ESR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ack any outstanding interrupts.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(EOI, <span class="number">0</span>);                               <span class="comment">// 向ioapic发送一个EOI，以免中断丢失</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send an Init Level De-Assert to synchronise arbitration ID&#x27;s.</span></span><br><span class="line">  <span class="built_in">lapicw</span>(ICRHI, <span class="number">0</span>);                             <span class="comment">// ？？？// 这里应该是向其他apic广播一条“报文”，通知“我”启动了</span></span><br><span class="line">  <span class="built_in">lapicw</span>(ICRLO, BCAST | INIT | LEVEL);          <span class="comment">// 广播的形式 &amp; 传送模式为INIT &amp; 水平触发</span></span><br><span class="line">  <span class="keyword">while</span>(lapic[ICRLO] &amp; DELIVS)                  <span class="comment">// 中断的传输状态：是否已经发送？</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enable interrupts on the APIC (but not on the processor).</span></span><br><span class="line">  <span class="built_in">lapicw</span>(TPR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上代码就是初始化BSP的lapic，在其他AP启动后，都要执行一遍这段代码。</strong></p>
<h3 id="ioapicinit：初始化ioapic"><a href="#ioapicinit：初始化ioapic" class="headerlink" title="ioapicinit：初始化ioapic"></a>ioapicinit：初始化ioapic</h3><p>ioapic的作用和单核架构下master pic很像，但是对于ioapic的初始化步骤很简单，不需要发送一系列的控制字。对于ioapic的初始化就是简单的配置一下重定向表项 RTE(Redirection Table Entry)，给RTE的每一项一个初值，设置它的中断向量号（起始T_IRQ0，T_IRQ0 &#x3D;&#x3D; 0x20），并且默认是中断屏蔽的。后续需要什么中断再对相应的Entry做配置即可，比如consoleinit为了使用键盘调用了ioapicenable去配置对应的Entry打开中断等。关于重定向表项 RTE(Redirection Table Entry)的解释，读者可以看一下这篇文章，讲的非常详细：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46645613/article/details/119207945">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ioapicinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, id, maxintr;</span><br><span class="line"></span><br><span class="line">  ioapic = (<span class="keyword">volatile</span> <span class="keyword">struct</span> ioapic*)IOAPIC;           <span class="comment">// 默认地址：0xFEC00000   // Default physical address of IO APIC</span></span><br><span class="line">  maxintr = (<span class="built_in">ioapicread</span>(REG_VER) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;       <span class="comment">// ioapic支持的最大中断号</span></span><br><span class="line">  id = <span class="built_in">ioapicread</span>(REG_ID) &gt;&gt; <span class="number">24</span>;                      <span class="comment">// 从寄存器读到的ioapic的ID</span></span><br><span class="line">  <span class="keyword">if</span>(id != ioapicid)                                  <span class="comment">// 必须一致</span></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;ioapicinit: id isn&#x27;t equal to ioapicid; not a MP\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark all interrupts edge-triggered, active high, disabled,</span></span><br><span class="line">  <span class="comment">// and not routed to any CPUs.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= maxintr; i++)&#123;    <span class="comment">// 初始化重定向表项 RTE(Redirection Table Entry)，这里和单核架构下主从PIC一样，先将所有的中断屏蔽掉，在后面初始化的时候再按需使能。</span></span><br><span class="line">    <span class="built_in">ioapicwrite</span>(REG_TABLE<span class="number">+2</span>*i, INT_DISABLED | (T_IRQ0 + i));</span><br><span class="line">    <span class="built_in">ioapicwrite</span>(REG_TABLE<span class="number">+2</span>*i<span class="number">+1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tvinit：初始化中断向量表"><a href="#tvinit：初始化中断向量表" class="headerlink" title="tvinit：初始化中断向量表"></a>tvinit：初始化中断向量表</h3><p>这里自顶向下介绍XV6的中断向量表是如何构造的。</p>
<p>涉及到的变量如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interrupt descriptor table (shared by all CPUs).</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gatedesc</span> idt[<span class="number">256</span>];   <span class="comment">// 中断描述符表</span></span><br><span class="line"><span class="keyword">extern</span> uint vectors[];  <span class="comment">// vectors的定义文件是：由vectors.pl生成的汇编代码文件。</span></span><br></pre></td></tr></table></figure>

<p>首先是tvinit函数，它是最顶层负责构造中断向量表的函数，SETGATE宏在上面已经贴过它的实现，这里简单介绍一个各个参数的作用。</p>
<p>SETGATE(gate, istrap, sel, off, d) ：</p>
<ul>
<li><p>参数1：对应idt[i]，表示每一项entry。</p>
</li>
<li><p>参数2：标记是中断门还是陷阱门。</p>
</li>
<li><p>参数3：段选择子。</p>
</li>
<li><p>参数4：中断处理函数地址。</p>
</li>
<li><p>参数5：中断描述符被哪个特权级使用。</p>
</li>
</ul>
<p>结合代码来看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">tvinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 构造中断描述符表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    <span class="built_in">SETGATE</span>(idt[i], <span class="number">0</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化系统调用中断描述符，类型是陷阱门（发生中断不会关中断），特权级是DPL_USER。</span></span><br><span class="line">  <span class="built_in">SETGATE</span>(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initlock</span>(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是vectors.pl文件生成汇编代码的过程，pl我之前也没有了解过，不过从它的代码可以看出，有点像字符串拼接的处理语言，简化了重复性代码的编写，代码如下：</p>
<figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate vectors.S, the trap/interrupt entry points.</span></span><br><span class="line"><span class="comment"># There has to be one entry point per interrupt number</span></span><br><span class="line"><span class="comment"># since otherwise there&#x27;s no way for trap() to discover</span></span><br><span class="line"><span class="comment"># the interrupt number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;# generated by vectors.pl - do not edit\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;# handlers\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;.globl alltraps\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">my</span> <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;.globl vector<span class="variable">$i</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;vector<span class="variable">$i</span>:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$i</span> == <span class="number">8</span> || (<span class="variable">$i</span> &gt;= <span class="number">10</span> &amp;&amp; <span class="variable">$i</span> &lt;= <span class="number">14</span>) || <span class="variable">$i</span> == <span class="number">17</span>))&#123;</span><br><span class="line">        <span class="comment"># 这些中断cpu自动压入errcode参数，</span></span><br><span class="line">        <span class="comment"># 为保证中断栈帧的统一，所以我们在</span></span><br><span class="line">        <span class="comment"># 这些特殊中断手动压入0值，这样就能</span></span><br><span class="line">        <span class="comment"># 统一使用trapret来恢复上下文。</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;  pushl \$0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;  pushl \$<span class="variable">$i</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;  jmp alltraps\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;\n# vector table\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;.data\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;.globl vectors\n&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;vectors:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">my</span> <span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;  .long vector<span class="variable">$i</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从pl代码上我们可以看到，就是利用for循环构造vectors数组，该数组专门存放中断处理函数。我们先来分析一下它如何构造vectors的，首先最上面有一个for循环，for循环中使用了一个if判断，因为有些中断cpu不会自动压入错误码，所以我们需要<strong>手动压入一个占位值</strong>，方便trapret的处理。在for循环下面最后压入了一个jmp指令，所以pl生成的汇编并不是中断处理函数最终代码，pl生成的中断处理函数会跳到alltraps，alltraps代码我们下面再进行分析。pl在最后生成的汇编代码定义了一个vectors数组，数组里面元素就是上面定义的256个vectori（i&#x3D;1、2、…）。</p>
<p>最后就是trapasm.S文件对alltraps的实现，常规的进行上下文保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mmu.h&quot;</span><br><span class="line"></span><br><span class="line">  # vectors.S sends all traps here.</span><br><span class="line">.globl alltraps</span><br><span class="line">alltraps:          # 保存上下文</span><br><span class="line">  # Build trap frame.</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal</span><br><span class="line">  </span><br><span class="line">  # Set up data segments.</span><br><span class="line">  movw $(SEG_KDATA&lt;&lt;3), %ax</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es</span><br><span class="line"></span><br><span class="line">  # Call trap(tf), where tf=%esp</span><br><span class="line">  pushl %esp</span><br><span class="line">  call trap       # 进入trap函数</span><br><span class="line">  addl $4, %esp</span><br><span class="line"></span><br><span class="line">  # Return falls through to trapret...</span><br><span class="line">.globl trapret</span><br><span class="line">trapret:          # 恢复上下文</span><br><span class="line">  popal</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl $0x8, %esp  # trapno and errcode</span><br><span class="line">  iret</span><br></pre></td></tr></table></figure>

<p>tvinit、pl、alltraps三者之间的关系总览图如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/trap__structure.png"></p>
<p>关于中断帧，这里要注意，涉及特权级转换的中断帧和不涉及特权级转换的中断帧有些许不一样。如下：</p>
<p>用户态触发中断（陷阱门或中断门）过程如下：</p>
<ol start="0">
<li><p>用户查询TSS（任务状态段）段，找到用户进程在内核态的栈段和栈顶指针（ss0、esp0）。</p>
</li>
<li><p><strong>cpu将ss、esp压入（内核）栈中。</strong>（硬件</p>
</li>
<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>
</li>
<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>
</li>
<li><p>调用trap函数，处理各种中断。</p>
</li>
<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>
</li>
<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>
</li>
<li><p>cpu恢复ss、esp。（硬件</p>
</li>
</ol>
<p>而内核线程发生中断（<strong>注意，内核态不会发生系统调用，这不应该也不合理</strong>），过程如下：</p>
<ol>
<li><p>cpu将eflags、cs、eip压入栈中。<strong>中断门还要关中断</strong>，陷阱门不用。（硬件</p>
</li>
<li><p>执行用户中断处理函数<strong>alltraps</strong>的<strong>上下文保护</strong>的代码。（软件</p>
</li>
<li><p>调用trap函数，处理各种中断。</p>
</li>
<li><p>执行用户中断处理函数<strong>trapret</strong>的<strong>上下文恢复</strong>的代码。（软件</p>
</li>
<li><p>调用iret，cpu恢复eflags、cs、eip。（硬件</p>
</li>
</ol>
<p>XV6中定义的栈帧结构体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 36</span></span><br><span class="line"><span class="comment">// Layout of the trap frame built on the stack by the</span></span><br><span class="line"><span class="comment">// hardware and by trapasm.S, and passed to trap().</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">trapframe</span> &#123;</span><br><span class="line">  <span class="comment">// registers as pushed by pusha</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      <span class="comment">// useless &amp; ignored</span></span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rest of trap frame</span></span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here defined by x86 hardware</span></span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here only when crossing rings, such as from user to kernel</span></span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>中断帧如下图：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/trap_frame.png"></p>
<p>图片引用自：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>
<h3 id="startothers：激活其他AP处理器"><a href="#startothers：激活其他AP处理器" class="headerlink" title="startothers：激活其他AP处理器"></a>startothers：激活其他AP处理器</h3><p>到这里终于要开始启动其他AP核了，AP核的启动也是一种固定套路，在<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf">多处理器规范</a>中这种套路称为universal algorithm。XV6中这个算法实现在lapicstartap函数中。</p>
<p>流程如下：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/universal_algorithm.png"></p>
<p>XV6代码启动其他AP处理器的核心流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the non-boot (AP) processors.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">startothers</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];</span><br><span class="line">  uchar *code;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c;</span><br><span class="line">  <span class="type">char</span> *stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write entry code to unused memory at 0x7000.</span></span><br><span class="line">  <span class="comment">// The linker has placed the image of entryother.S in</span></span><br><span class="line">  <span class="comment">// _binary_entryother_start.</span></span><br><span class="line">  <span class="comment">// AP核的entryother代码的入口点，entryother 就是 boot + entry的结合体</span></span><br><span class="line">  code = <span class="built_in">P2V</span>(<span class="number">0x7000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里将entryother的代码移到物理地址0x7000处</span></span><br><span class="line">  <span class="built_in">memmove</span>(code, _binary_entryother_start, (uint)_binary_entryother_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BSP for循环向每个AP发送中断。</span></span><br><span class="line">  <span class="keyword">for</span>(c = cpus; c &lt; cpus+ncpu; c++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="built_in">mycpu</span>())  <span class="comment">// We&#x27;ve started already.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell entryother.S what stack to use, where to enter, and what</span></span><br><span class="line">    <span class="comment">// pgdir to use. We cannot use kpgdir yet, because the AP processor</span></span><br><span class="line">    <span class="comment">// is running in low  memory, so we use entrypgdir for the APs too.</span></span><br><span class="line">    stack = <span class="built_in">kalloc</span>();   <span class="comment">// 为每个AP核分配一个执行scheduler函数的内核栈</span></span><br><span class="line">    *(<span class="type">void</span>**)(code<span class="number">-4</span>) = stack + KSTACKSIZE;</span><br><span class="line">    *(<span class="built_in">void</span>(**)(<span class="type">void</span>))(code<span class="number">-8</span>) = mpenter;  <span class="comment">// 指定AP特有main（mpenter）函数入口点。</span></span><br><span class="line">    <span class="comment">// 同BSP刚启动一样，使用使用4M big page页表。</span></span><br><span class="line">    *(<span class="type">int</span>**)(code<span class="number">-12</span>) = (<span class="type">void</span> *) <span class="built_in">V2P</span>(entrypgdir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lapicstartap就是实现了universal algorithm，因为我也不太懂，这里就不贴了。</span></span><br><span class="line">    <span class="built_in">lapicstartap</span>(c-&gt;apicid, <span class="built_in">V2P</span>(code));   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待AP初始化完毕</span></span><br><span class="line">    <span class="comment">// wait for cpu to finish mpmain()</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;started == <span class="number">0</span>)  </span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个AP boot点和BSP的boot点类似，BSP是在0x7c00启动，AP是在0x7000启动。同样，0x7000也会执行一段汇编代码，这段汇编代码作用就是bootasm.S + entry.S代码的结合体。这里简单总结一下：</p>
<ol>
<li><p>加载临时全局描述符，进入保护模式</p>
</li>
<li><p>使用entrypgdir开启分页。</p>
</li>
<li><p>切换到预分配的内核（scheduler）栈。</p>
</li>
<li><p>进入mpenter。</p>
</li>
</ol>
<p>考虑到文章太长，代码就不放了。文件是entryother.S，有兴趣的读者可自行研究。</p>
<p>mpenter代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Other CPUs jump here from entryother.S.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mpenter</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  switchkvm();    <span class="comment">// 切换到粒度更小（4k）的内核页，kpgdir。</span></span><br><span class="line">  <span class="built_in">seginit</span>();       <span class="comment">//效果同BSP，在main中BSP也调用了该函数。就是第二次初始化段描述符。（第一次是在entryother.S</span></span><br><span class="line">  <span class="built_in">lapicinit</span>();    <span class="comment">// 效果同BSP</span></span><br><span class="line">  <span class="built_in">mpmain</span>();       <span class="comment">// 进入mpmain</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面那段代码就是：AP会像BSP那样，调用一遍所有的和CPU相关初始化函数，最终进入mpmain。（BSP在main最后也会进入mpmain，前面提到过BSP启动其他后，也成为了一个AP）</p>
<p>mpmain在加载中断描述符表后，最终就会进入scheduler，CPU正式开启操作系统的任务调度！</p>
<p>mpmain如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Common CPU setup code.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mpmain</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cprintf</span>(<span class="string">&quot;cpu%d: starting %d\n&quot;</span>, <span class="built_in">cpuid</span>(), <span class="built_in">cpuid</span>());</span><br><span class="line">  <span class="built_in">idtinit</span>();       <span class="comment">// load idt register</span></span><br><span class="line">  <span class="built_in">xchg</span>(&amp;(<span class="built_in">mycpu</span>()-&gt;started), <span class="number">1</span>); <span class="comment">// tell startothers() we&#x27;re up</span></span><br><span class="line">  <span class="built_in">scheduler</span>();     <span class="comment">// start running processes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>首先了解一下XV6对CPU的定义，注释写的非常详细：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> &#123;</span><br><span class="line">  <span class="comment">// lapci的id</span></span><br><span class="line">  uchar apicid;                <span class="comment">// Local APIC ID</span></span><br><span class="line">  <span class="comment">// 执行调度器栈指针</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">context</span> *scheduler;   <span class="comment">// swtch() here to enter scheduler</span></span><br><span class="line">  <span class="comment">// 任务状态段、为进程从用户态陷入内核态切栈使用</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">taskstate</span> ts;         <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">  <span class="comment">// 全局描述符</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">segdesc</span> gdt[NSEGS];   <span class="comment">// x86 global descriptor table</span></span><br><span class="line">  <span class="comment">// 指示cpu是否启动</span></span><br><span class="line">  <span class="keyword">volatile</span> uint started;       <span class="comment">// Has the CPU started?</span></span><br><span class="line">  <span class="comment">// 关中断的深度</span></span><br><span class="line">  <span class="type">int</span> ncli;                    <span class="comment">// Depth of pushcli nesting.</span></span><br><span class="line">  <span class="comment">// 记录在cpu第一层关中断前，中断关闭情况</span></span><br><span class="line">  <span class="type">int</span> intena;                  <span class="comment">// Were interrupts enabled before pushcli?</span></span><br><span class="line">  <span class="comment">// cpu当前运行的进程PCB</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *proc;           <span class="comment">// The process running on this cpu or null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">cpu</span> cpus[NCPU]; <span class="comment">// 多个cpu</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ncpu;              <span class="comment">// cpu的个数</span></span><br></pre></td></tr></table></figure>

<p>下面列出了各个CPU资源的共享情况，可以做一个参考：</p>
<table>
<thead>
<tr>
<th align="center">资源</th>
<th align="center">共享</th>
<th align="center">不共享</th>
</tr>
</thead>
<tbody><tr>
<td align="center">中断描述符表</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">lapic（也指外中断，包括定时器等）</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">ioapic</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">cpu的各种寄存器，包括eip、esp、eflag等等</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">全局描述符表（包括任务状态段）</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">kpgdir（内核调度器使用的页表）</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">物理内存</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">任务队列（ptable）</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">调度器的执行栈</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">外设</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>接下来是XV6的PCB（进程控制块），之前老是在教科书上看到它，当时感觉很难理解，在分析过OS源码后，再回过头去看，就感觉特别通透。XV6的PCB就是一个结构体，里面存放了很多成员，XV6的PCB和进程的内核栈是分开的，PCB结构体是通过一个指针来指向进程的内核栈。相比之下，Onix的PCB和内核栈是连在一起的，内核栈的低地址就是存放的PDB结构体，因为esp是线下增长，所以esp指向高地址处，并且典型的内核栈大小是一页（4K）（于是esp指向页面的4K处）。</p>
<p>XV6的PCB定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">procstate</span> &#123; UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">  <span class="comment">// 进程（映射了页框的）虚拟内存大小</span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="comment">// 进程的页表</span></span><br><span class="line">  <span class="type">pde_t</span>* pgdir;                <span class="comment">// Page table</span></span><br><span class="line">  <span class="comment">// 进程的内核栈</span></span><br><span class="line">  <span class="type">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="comment">// 进程状态</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">procstate</span> state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="comment">// 进程pid</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line">  <span class="comment">// 进程的父进程</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *parent;         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="comment">// 调用系统调用时的栈帧</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">trapframe</span> *tf;        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="comment">// 内核态的上下文</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">context</span> *context;     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="comment">// 等待条件</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="comment">// 是否被杀死</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="comment">// 打开的文件</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">  <span class="comment">// 工作目录的inode</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="comment">// 进程名</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;       <span class="comment">// 自旋锁</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> proc[NPROC];</span><br><span class="line">&#125; ptable;                     <span class="comment">// 多个cpu之间共享该结构</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc</span> *initproc; <span class="comment">// 存放init进程PCB</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;              <span class="comment">// 分配唯一pid</span></span><br></pre></td></tr></table></figure>

<p>XV6为进程定义了6种状态：UNUSED（PCB未使用）, EMBRYO（初始化中）, SLEEPING（阻塞休眠）, RUNNABLE（可调度）, RUNNING（运行中）, ZOMBIE（僵尸&#x2F;待回收）。 这里特别说明一下PCB的chan成员，该成员一个进程的等待条件。XV6中一个进程可能会调用sleep、wait系統調用，或者在調用read系統調用时间接调用了sleeplock，这些函数都会使一个进程进入阻塞状态，XV6的阻塞状态统一使用SLEEPING来表示，阻塞就是为了等待某个条件发生，当等待的条件发生时，阻塞的进程就会被唤醒，但是ptable有那么多阻塞的进程，我应该唤醒ptable中的哪些进程呢？此时chan就起到关键作用，在进程进入阻塞之前，会将chan设置为某一个变量的地址，当条件满足XV6就是通过chan来唤醒对应的进程的，当然这个变量的选取是很有讲究的，比如在XV6中因为sleep而休眠的进程，它的chan会被设置成ticks（作用类似jefrris，定时器中断的计数器）的地址。具体细节就不深入讨论，感兴趣的读者可以看看XV6的源码。</p>
<p>从AP（从）处理器的启动段落我们知道，BSP、AP最终都进入scheduler函数，铺垫了这么久，scheduler函数也是本文的主题，那么先来看看它的代码实现吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 42</span></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//      via swtch back to the scheduler.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();  <span class="comment">// 找到scheduler正运行在哪个cpu上</span></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;              <span class="comment">// 将cpu结构体的当前运行的进程清零</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Enable interrupts on this processor.</span></span><br><span class="line">    <span class="built_in">sti</span>();                  <span class="comment">// 打开中断、之前中断一直是关闭的！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里pushcli保存的mycpu()-&gt;intena其实没有意义，在切换后会被外面的sched直接覆盖。</span></span><br><span class="line">    <span class="comment">// Loop over process table looking for process to run.</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;ptable.lock); <span class="comment">// 共用ptable，所以需要获取自旋锁，互斥访问。</span></span><br><span class="line">    <span class="comment">// 遍历ptable</span></span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != RUNNABLE)  <span class="comment">// 进程状态不可运行</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// else 找到了一个可运行的进程</span></span><br><span class="line">      <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">      <span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line">      <span class="comment">// before jumping back to us.</span></span><br><span class="line">      c-&gt;proc = p;  <span class="comment">// 设置p为cpu当前运行进程</span></span><br><span class="line">      <span class="comment">//  这个函数非常关键，主要做两个三个操作：</span></span><br><span class="line">      <span class="comment">// 1、设置tss，并将其追加到全局描述符</span></span><br><span class="line">      <span class="comment">// 2、设置tss的选择子</span></span><br><span class="line">      <span class="comment">// 3、让cpu使用进程p的页表。</span></span><br><span class="line">      switchuvm(p);</span><br><span class="line">      p-&gt;state = RUNNING; <span class="comment">// 设置p为运行状态</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">swtch</span>(&amp;(c-&gt;scheduler), p-&gt;context); <span class="comment">// 正式开始切换，等到p放弃cpu才会返回</span></span><br><span class="line">      switchkvm();        <span class="comment">// 切换回内核页表kpgdir</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      c-&gt;proc = <span class="number">0</span>;        <span class="comment">// 当前运行的进程清零</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;ptable.lock);  <span class="comment">// 释放自旋锁</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XV6的调度算法非常简单，就是简单的round robin算法。主要精华是整个调度的过程，至于它具体的调度算法其实显得并不是特别重要。</p>
<p>switchuvm函数实现非常关键，它里面会设置tss，并且设置cpu使用进程p的页表。<strong>tss全称是任务状态段，它可以帮助处于用户态的进程回到内核态</strong>，因为一个进程有两个栈，一个是出于用户态使用，另外一个是处于内核态使用，进程从内核态转变成用户态容易。只需要将中断帧弹出恢复上下文即可，但是从用户态回到内核态就难了，因为进入用户态后，进程的用户态空间不会保留进程任何内核态信息，所以，我们需要一个东西来帮助处于用户态的进程在需要陷入内核态时，找到它的内核态的栈，这个东西就是TSS，TSS会记录一个进程的内核栈的栈指针esp和栈段ss，switchuvm函数正是完成了这样的功能。实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch TSS and h/w page table to correspond to process p.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;switchuvm: no process&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kstack == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;switchuvm: no kstack&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pgdir == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;switchuvm: no pgdir&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pushcli</span>();</span><br><span class="line">  <span class="comment">// 因为tss也是一个段，所以向cpu的全局描述符中追加tss的描述符</span></span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;gdt[SEG_TSS] = <span class="built_in">SEG16</span>(STS_T32A, &amp;<span class="built_in">mycpu</span>()-&gt;ts,</span><br><span class="line">                                <span class="built_in">sizeof</span>(<span class="built_in">mycpu</span>()-&gt;ts)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;                 <span class="comment">// 内核栈段</span></span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;  <span class="comment">// 内核栈指针</span></span><br><span class="line">  <span class="comment">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class="line">  <span class="comment">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">  <span class="built_in">ltr</span>(SEG_TSS &lt;&lt; <span class="number">3</span>);                                <span class="comment">// tss段选择子</span></span><br><span class="line">  <span class="comment">// 切换到p的页表</span></span><br><span class="line">  <span class="built_in">lcr3</span>(<span class="built_in">V2P</span>(p-&gt;pgdir));  <span class="comment">// switch to process&#x27;s address space</span></span><br><span class="line">  <span class="built_in">popcli</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于任务状态段的详情描述可以参考：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md">https://github.com/StevenBaby/onix/blob/dev/docs/07%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/062%20%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%E7%AE%80%E4%BB%8B.md</a></p>
<p>swtch函数由汇编实现，是进程切换的核心函数，实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context **old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save the current registers on the stack, creating</span><br><span class="line"># a struct context, and save its address in *old.</span><br><span class="line"># Switch stacks to new and pop previously-saved registers.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:                # 这里有个pushl eip，cpu帮我们自动执行了</span><br><span class="line">  movl 4(%esp), %eax  # 第一个参数，struct context**</span><br><span class="line">  movl 8(%esp), %edx  # 第二个参数  struct context*</span><br><span class="line"></span><br><span class="line">  # Save old callee-saved registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax) # 加括号和在指针前面加*一个道理，这里保存当前内核栈指针到第一个参数上</span><br><span class="line">  movl %edx, %esp   # 将esp切换到第二个参数指向的内核栈上</span><br><span class="line"></span><br><span class="line">  # Load new callee-saved registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>struct context结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">context</span> &#123;</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个进程在（因为时间片用完）需要放弃cpu执行权限，如何回到scheduler呢？答案就是使用sched函数，本文我们以普遍的事件来分析————因为时间片用完而放弃的cpu。处于<strong>用户态的进程因为时间片用完会发生定时器中断</strong>，定时器中断又会引发从用户态到内核态的切栈、保存上下文、执行trap函数，trap函数中最后调用了yield，yield最终会调用sched，trap函数伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">spinlock</span> tickslock;</span><br><span class="line">uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PAGEBREAK: 41</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tf-&gt;trapno == T_SYSCALL)&#123;  <span class="comment">// 是系统调用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(tf-&gt;trapno)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cpuid</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">      ticks++;            <span class="comment">// 每次定时器中断都自增1</span></span><br><span class="line">      <span class="built_in">wakeup</span>(&amp;ticks);     <span class="comment">// 唤醒sleeping进程，检查休眠是否到期</span></span><br><span class="line">      <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">lapiceoi</span>();           <span class="comment">// 通知lapic中断处理完毕</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force process to give up CPU on clock tick.</span></span><br><span class="line">  <span class="comment">// If interrupts were on while locks held, would need to check nlock.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">myproc</span>() &amp;&amp; <span class="built_in">myproc</span>()-&gt;state == RUNNING &amp;&amp;</span><br><span class="line">     tf-&gt;trapno == T_IRQ0+IRQ_TIMER)</span><br><span class="line">    <span class="built_in">yield</span>();    <span class="comment">// 时间片用完，cpu让给下一个进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yield函数实现就是封装了一下sched函数，在调用sched之前，将进程的状态设置成了RUNNABLE状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enter scheduler.  Must hold only ptable.lock</span></span><br><span class="line"><span class="comment">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class="line"><span class="comment">// intena because intena is a property of this</span></span><br><span class="line"><span class="comment">// kernel thread, not this CPU. It should</span></span><br><span class="line"><span class="comment">// be proc-&gt;intena and proc-&gt;ncli, but that would</span></span><br><span class="line"><span class="comment">// break in the few places where a lock is held but</span></span><br><span class="line"><span class="comment">// there&#x27;s no process.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holding</span>(&amp;ptable.lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched ptable.lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;ncli != <span class="number">1</span>)        <span class="comment">// 最多一层关中断</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)       <span class="comment">// 在调用sched前，应该改变进程状态</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">readeflags</span>()&amp;FL_IF)        <span class="comment">// 中断必须被关闭！</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">  intena = <span class="built_in">mycpu</span>()-&gt;intena;     <span class="comment">// intena是进程私有的</span></span><br><span class="line">  <span class="built_in">swtch</span>(&amp;p-&gt;context, <span class="built_in">mycpu</span>()-&gt;scheduler); <span class="comment">// 切换到scheduler</span></span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;intena = intena;     <span class="comment">// 还原intena</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">yield</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ptable.lock);  <span class="comment">//DOC: yieldlock</span></span><br><span class="line">  <span class="built_in">myproc</span>()-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="built_in">sched</span>();</span><br><span class="line">  <span class="built_in">release</span>(&amp;ptable.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sched中保存intena状态到进程的内核栈中的做法，好像把intena变量放到PCB中更合适，但是XV6没有这么做。从shced函数注释中了解到，如果把intena变量放到PCB中的话，有些情况下会有问题。具体呢，就不去细究了（我也每深究），本文内容太长了，还是以调度为主。这里主要是想表达一个点：<strong>scheduler函数给ptable.lock加锁时，pushcli保存的intena没有任何意义。因为最终在切换进程时，会被sched中进程的intena给覆盖掉。同样，在进程回到scheduler函数后，scheduler函数给ptable.lock解锁时，popcli还原的intena也没有任何意义，因为无论intena原来是否开中断，外层的for都会开中断！</strong></p>
<p>最终，一个待调度的进程的内核栈帧就形成了：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/task_stack.drawio.png"></p>
<p>一张图片概括yield、scheduler的加锁关系。如下图，进程利用yield进入调度器时会获取ptable的自旋锁（自旋锁内部会关中断，并且将关中断之前的中断状态保存到intena中），在切换到scheduler后（可能）会由scheduler解锁。在从scheduler切换到下一个任务前，（可能）scheduler会获取ptable的自旋锁，在却换到下一个任务后，由任务进行解除ptable的自选锁，注意这里是可能，因为还有可能scheduler的内层循环还没有执行完，以至于内层循环还可以找到下一个待执行的日任务，此时ptable的锁，就是：老进程加锁，新进程解锁：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/yield_scheduler.png"></p>
<p>总的来说，XV6进程调度整体流程是：<strong>每个cpu上都运行调度线程，调度线程运行sheduler函数，scheduler不断从ptable取进行任务，然后（swapIn）切换去执行进程任务，当进程任务用完时间片（通过定时器中断）就会放弃cpu的执行权限，（swapOut）切换到内核调度线程继续去调度下一个进程任务。</strong></p>
<p>如果类比于用户态的协程的：<strong>对称协程和非对称协程之分吗的话，结合非对称协程的特点：协程的切换需要经过调度协程，而由于XV6进程的调度都必须经内核的过调度线程，所以XV6的调度器模型更像一种“非对称进程”。</strong></p>
<p><strong>作为对比，如果你阅读过Onix的代码，你会发现Onix的调度模型更像是一种”对称进程“，因为Onix的进程切换是两个进程之间直接进行，不存在中间的调度线程。</strong></p>
<p>这里我可以用一张<strong>类似sylar的协程调度器模型来总结XV6进程调度模型</strong>：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler.drawio.png"></p>
<p><strong>其实CPU Pool和线程池非常像，XV6的每个CPU都互斥到ptable中去取进程，然后去消化进程。唯一的区别就是CPU要和很多寄存器、硬件打交道，但是最终整体的框架思想都是一同百通，</strong></p>
<p>如果你看过sylar的源码，你会深有感触！ <strong>sylar的协程调度器模型和XV6进程的调度模型不能说像，只能是真的一模一样！</strong> sylar是一个C++的基于协程的网络框架。我之前也有写过sylar的博客，这里推荐大家去看看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52566365/article/details/135991331%E3%80%82">https://blog.csdn.net/m0_52566365/article/details/135991331。</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>XV6有很多地方写的很暴力，有很大的优化空间，比如：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">XV6做法</th>
<th align="center">Onix做法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存管理</td>
<td align="center">不管是物理内存还是内核内存一股脑使用kalloc，用户页表所有的内容都靠kalloc</td>
<td align="center">get_page（使用256个页管理4G物理页，专门给页表和页框分配内存&#x2F;page） + alloc_kpage（专门给内核分配内核页所有的页目录都采用alloc_kpage&#x2F;page） + kmalloc（使用了内存池专门管理内核中的小快内存&#x2F;byte）</td>
</tr>
<tr>
<td align="center">内核对系统调用参数的获取</td>
<td align="center">直接访问用户栈空间</td>
<td align="center">使用ebp、edi、esi、edx、ecx、ebx寄存器获取系统调用参数</td>
</tr>
<tr>
<td align="center">软件定时器</td>
<td align="center">没有实现软件定时器</td>
<td align="center">利用链表实现了软件定时器</td>
</tr>
<tr>
<td align="center">内存探测</td>
<td align="center">未实现内存探测</td>
<td align="center">loader实现了内存探测</td>
</tr>
<tr>
<td align="center">idle任务</td>
<td align="center">没实现idle任务</td>
<td align="center">实现了idle任务</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>从上表可以看到Onix每一项都是存在优势的。但是Onix唯一的缺点，也是我读了Onix源码又来读XV6源码的原因：Onix是一个<strong>单核</strong>OS。其实读完XV6了解了多核OS的实现后，也没感到很大的震撼，多核CPU无非就是比单核CPU多了几套eip、esp、eflag等cpu相关的寄存器，cpu访问共享资源的的时候注意加锁就好了。</p>
<p>最后谈谈XV6调度模型的优化：从<strong>XV6进程调度模型图</strong>我们可以看到，XV6的调度模型可以参考Muduo的One loop per thread 思想（可能说Muduo的One loop per thread思想参考了现代Linux对CPU的调度模型更合适？），因为XV6进程调度模型非常暴力，所有cpu共享有一个任务池（ptable），锁的竞争非常激烈。我们可以考虑让每个cpu都拥有一个自己独立的ptable（当然里面还是有自旋锁），由一个cpu负责负载均衡，将任务均匀的分发给各个cpu，需要修改cpux内部数据结构时，其他cpu只需向cpux的回调队列中添加操作函数即可，具体的操作还是由cpux自己完成。<strong>也即One loop per CPU</strong>。如下图：</p>
<p><img src="/2024/06/08/xv6/Scheduler/photo/scheduler/scheduler_pluse.drawio.png"></p>
<p>终于4干完了这篇文章，字数预计上万了，第一次写这么长的文章，也是真的用心了。创作不易，赏个赞把！</p>
<p><strong>参考资料</strong></p>
<p>多处理器规范：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf">https://pdos.csail.mit.edu/6.828/2014/readings/ia32/MPspec.pdf</a></p>
<p>XV6的官方中文文档：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf</a></p>
<p>Onix单核操作系统：<a target="_blank" rel="noopener" href="https://github.com/StevenBaby/onix/">https://github.com/StevenBaby/onix/</a></p>
<p>APIC中断讲解比较好的范文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46645613/article/details/119207945">https://blog.csdn.net/weixin_46645613/article/details/119207945</a></p>
<p>多核处理器启动博客1：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/394247844">https://zhuanlan.zhihu.com/p/394247844</a></p>
<hr>
<p><strong>本章完结</strong></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="半个馒头 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%B1%BBUnix%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" rel="tag"># 类Unix源码剖析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/07/xv6/Boot/" rel="prev" title="这才是计科之 Onix & XV6 源码分析（1、XV6-x86的启动）">
      <i class="fa fa-chevron-left"></i> 这才是计科之 Onix & XV6 源码分析（1、XV6-x86的启动）
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/08/linux_driver/fusing/" rel="next" title="烧写uboot、linux镜像、根文件系统到开发板">
      烧写uboot、linux镜像、根文件系统到开发板 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Onix%E5%8D%95%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">Onix单核处理器的中断原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XV6%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%AD%E6%96%AD%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">XV6多核处理的中断原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">中断描述符表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AP%EF%BC%88%E4%BB%8E%EF%BC%89%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">3.</span> <span class="nav-text">AP（从）处理器的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mpinit%EF%BC%9A%E6%8E%A2%E6%B5%8B%E5%90%84%E4%B8%AAcpu"><span class="nav-number">3.1.</span> <span class="nav-text">mpinit：探测各个cpu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lapicinit%EF%BC%9ABSP%E5%88%9D%E5%A7%8B%E5%8C%96%E8%87%AA%E5%B7%B1cpu%E7%9A%84lapic"><span class="nav-number">3.2.</span> <span class="nav-text">lapicinit：BSP初始化自己cpu的lapic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ioapicinit%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96ioapic"><span class="nav-number">3.3.</span> <span class="nav-text">ioapicinit：初始化ioapic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tvinit%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">tvinit：初始化中断向量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startothers%EF%BC%9A%E6%BF%80%E6%B4%BB%E5%85%B6%E4%BB%96AP%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">3.5.</span> <span class="nav-text">startothers：激活其他AP处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="半个馒头"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">半个馒头</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LunarStore" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LunarStore" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18772124875@163.com" title="网易邮箱 → mailto:18772124875@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-fas fa-envelope"></i>网易邮箱</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/m0_52566365" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_52566365" rel="noopener" target="_blank">CSDN博客地址</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">半个馒头</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
